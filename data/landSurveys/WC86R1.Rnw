\documentclass{article}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{lscape}
\usepackage{float}
\usepackage{adjustbox}
\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Analysis of wallaby and kangaroo line transect data}
\author{David L. Borchers and Martin J. Cox}
\maketitle
\section{Summary}
\begin{enumerate}
\item I am a little concerned that I have missed something by not scaling the positions in the previous analysis, so I am going to do so here.
\end{enumerate}

\section{Overview}
This analysis is confined to examining the wallaby sighting line transect data where the transects were orientated North-South.  I selected the North-South direction because the transect lengths were similar and the range of transect observation durations, no worse than the East-West transect durations. 

\subsection{User defined variables}
<<userVar>>=
w=160 #m (half inter-transect spacing)
ystart=400 #m  
wy=160#20 # y-dimesion truncation distance
@
I am adding a 'scale factor' to reduce the apparent survey area size in order to better accommodate alternative hazard functions.  I may have missed something here, and this could be complete nonsense, but I thought I'd try it:
<<sf>>=
scaleFactor=100
@
Load \texttt{R} packages:
<<loadRpackages>>=
source('~/Dropbox/packages/2D distance sampling with time/R/2DLTfunctions.r')
library(xlsx)
library(psych)
library(xtable)
library(scatterplot3d)
library(rgl)
@
Next we read in sightings and transect data.  To do so, we will need the \texttt{xlsx} package.
<<readData>>=
transects=read.xlsx('~/Dropbox/packages/2D distance sampling with time/data/landSurveys/WC86TN.xlsx',sheetIndex=1)
sightings=read.xlsx('~/Dropbox/packages/2D distance sampling with time/data/landSurveys/WC86IS.xlsx',sheetIndex=1)  
@
Merge the data:
<<merge>>=
sightings=merge(sightings,transects,'TNNU')
@
Now we'll subset the data, retaining the wallaby data on North-South transects
<<sub1>>=
nrow(sightings)
sub=subset(sightings,SPEC=='RNW' & TBRG %in% c(90,270))#c(0,180))## )
nrow(sub)
@
\section{Calculate x,y coordinates}
Calculate x and y coordinates:
<<XY>>=
sub$X=with(sub,RADL*sin(ANGL*pi/180))
sub$Y=with(sub,RADL*cos(ANGL*pi/180))
@
We take \texttt{ANGL} to be a relative bearing to the sighting with 90 deg being abeam or perpendicular to the transect, so we remove sightings where \texttt{ANGL}$>$90 deg:
<<angTH90>>=
nrow(sub)
sub=subset(sub,ANGL<=90)
nrow(sub)
@
and subset on truncation distances:
<<trunc>>=
nrow(sub)
sub=subset(sub,X<w & Y<wy)
nrow(sub)
@
Remove non-zero y-distances:
<<ydist>>=
sub$Y[sub$Y<1]=1
@
We need the transects to be observed at a constant speed so checking transect speed:
\begin{figure}
\begin{center}
<<label=fig1,fig=TRUE,echo=FALSE>>=
par(mfrow=c(1,2))
hist(sub$TLGT,main='Transect length',xlab='transect length, km')
hist(sub$TLGT*60/(sub$TDUR),main='Speed',xlab='transect speed, kmh^-1')
@
\end{center}
\caption{Transect lengths and survey speeds.}
\label{fig:one}
\end{figure}

and the direction of transects:
<<transectDir>>=
table(sub$TBRG)
@

Display the sightings
\begin{figure}
\begin{center}
<<label=fig2,fig=TRUE,echo=FALSE>>=
with(sub, scatter.hist(X, Y, xlab="X",smooth=FALSE,correl=FALSE,title='RNW',
                              ylab="Y",col=as.numeric(as.factor(TDRN)),pch=19,cex=0.5))
@
\end{center}
\caption{Observations for wallabys (RNW).}
\label{fig:two}
\end{figure}

\subsection{Group size as a covariate}
<<groupSizePlot>>=
with(sub,scatterplot3d(x=X,y=Y,z=GPSZ,color=as.numeric(as.factor(TDRN)),type="h",angle=60))
@

Also using \texttt{rgl}:
<<rgl3D>>=
with(sub,plot3d(x=X,y=Y,z=GPSZ,col=as.numeric(as.factor(TDRN)),type="h"))
@

\subsection{Analysis of the NS and SN wallaby (RNW) sightings}
Models are fit using the wallaby sighting data.  Three perpendicular density functions are considered: (i) uniform; (ii) half-normal, and (iii) normal.  
The models take a while to fit, so the results have been stored in an \texttt{R} workspace:
<<loadWS,eval=TRUE>>=
load('~/Dropbox/packages/2D distance sampling with time/data/landSurveys/workspace.RData')
#get revised functions:
source('~/Dropbox/packages/2D distance sampling with time/R/2DLTfunctions.r')


@

<<fitRNWData,eval=FALSE>>=
#fit uniform perpendicular density function with h1 hazard function:
mod1.unif.h1=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=log(c(1,1)),hr=h1,
                 ystart=ystart/scaleFactor,
                 pi.x=pi.const,logphi=NULL,w=w/scaleFactor,hessian=TRUE)

#fit half-normal perpendicular density function with h1 hazard function:
mod2.hn.h1=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=log(c(1,1)),hr=h1,
               ystart=ystart/scaleFactor,
                 pi.x=pi.hnorm,logphi=1,w=w/scaleFactor,hessian=TRUE)

#normal perpendicular density function with h1 hazard function:
mod3.n.h1=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-1.65,0.86),hr=h1,
              ystart=ystart/scaleFactor,
                 pi.x=pi.norm,logphi=c(0.1,1),w=w/scaleFactor,hessian=TRUE)

@
Now models are fit using the \texttt{h2} hazard function:
<<modelFith2,eval=FALSE>>=
#fit uniform perpendicular density function with h2 hazard function:
mod4.unif.h2=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=log(c(0.75,1)),hr=h2,
                 ystart=ystart/scaleFactor,
                 pi.x=pi.const,logphi=NULL,w=w/scaleFactor,hessian=TRUE)

#fit half-normal perpendicular density function with h2 hazard function:
mod5.hn.h2=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-1.9,-0.48),hr=h2,
               ystart=ystart/scaleFactor,
                 pi.x=pi.hnorm,logphi=2,w=w/scaleFactor,hessian=TRUE)

#normal perpendicular density function with h2 hazard function:
mod6.n.h2=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-1.9,-0.48),hr=h2,
              ystart=ystart/scaleFactor,
                 pi.x=pi.norm,logphi=c(0.1,1),w=w/scaleFactor,hessian=TRUE)


@
Using the Okamura et al. (2003) hazard function:
<<modelSelectOkamura,eval=FALSE>>=
#fit uniform perpendicular density function with the h.okamura hazard function:
mod7.unif.h.okamura=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=log(c(0.75,1)),hr=h.okamura,
                 ystart=ystart/scaleFactor,
                 pi.x=pi.const,logphi=NULL,w=w/scaleFactor,hessian=TRUE)

#fit half-normal perpendicular density function with the h.okamura hazard function:
mod8.hn.h.okamura=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-0.93,-0.77),hr=h.okamura,
               ystart=ystart/scaleFactor,
                 pi.x=pi.hnorm,logphi=1,w=w/scaleFactor,hessian=TRUE)
#fit a normal perpendicular density function with the h.okamura hazard function:
mod9.n.h.okamura=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-0.93,-0.77),hr=h.okamura,
               ystart=ystart/scaleFactor,
                 pi.x=pi.norm,logphi=c(1,1),w=w/scaleFactor,hessian=TRUE)


@
Also fit with the exponential power hazard model of Skaug \& Schweder 1999:
<<fitPowerEXp,eval=FALSE>>=
#fit uniform perpendicular density function with the Exponential power hazard model of Skaug & Schweder 1999 for the hazard function:
mod10.unif.h.exp=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=log(c(0.75,0.9)),hr=h.exp2,
                 ystart=ystart/scaleFactor,
                 pi.x=pi.const,logphi=NULL,w=w/scaleFactor,hessian=TRUE)

#fit half-normal perpendicular density function with the Exponential power hazard model of Skaug & Schweder 1999 for the hazard function:
mod11.hn.h.exp=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-1.77,-0.26),hr=h.exp2,
               ystart=ystart/scaleFactor,
                 pi.x=pi.hnorm,logphi=7,w=w/scaleFactor,hessian=TRUE)
#fit a normal perpendicular density function with the Exponential power hazard model of Skaug & Schweder 1999 for the hazard function:
mod12.n.h.exp=fityx(y=sub$Y/scaleFactor,x=sub$X/scaleFactor,b=c(-1.77,-0.26),hr=h.exp2,
               ystart=ystart/scaleFactor,
                 pi.x=pi.norm,logphi=c(1,1),w=w/scaleFactor,hessian=TRUE)
@
Create a list of models:
<<modList>>=
modL=list(h1.unif=mod1.unif.h1,h1.hn=mod2.hn.h1,
          h1.n=mod3.n.h1,
                      h2.unif=mod4.unif.h2,h2.hn=mod5.hn.h2,h2.norm=mod6.n.h2,
                      h.okamura.unif=mod7.unif.h.okamura,
                      h.okamura.hn=mod8.hn.h.okamura,
                      h.okamura.norm=mod9.n.h.okamura,
                      h.exp.unif=mod10.unif.h.exp,
                      h.exp.hn=mod11.hn.h.exp,
                      h.exp.n=mod12.n.h.exp)
@
Remove models with fit errors:
<<fitError>>=
me=sapply(modL,function(x) x$error)
modLR=modL[!me]
@
I am suspicous of the Okamura hazard rate models, I wonder if these models have got stuck at a local minima.  Perhaps using different starting parameter values could check this.  For now, I will remove the Okamura models:
<<remove.okamura>>=
modLR=modLR[-grep('okamura',names(modLR))]
@
AIC-based model selection was carried out using the \texttt{modSelect} function:

<<modSelect>>=
aicTab=modSelect(modLR,modNames=names(modLR),tab=TRUE)
@
Estimate $\hat{p}$ with confidence intervals obtained using the delta method as well as $\hat{N}$:

<<Nhat>>=
phatTab=phatModels(modList=modLR[aicTab$AICorder],n=nrow(sub),tab=TRUE)
tab1=xtable(cbind(aicTab$tab,phatTab$tab),label='tab:model.sel',
            caption='AIC-based model selection for the various combinations of hazard and 
            perpendicular density functions. n is the number of parameters.  () is the coefficient
            of variation, or for Nhat is the 95 confidence interval.')
@
Order models by AIC:
<<AICorder>>=
modLR=modLR[aicTab$AICorder]
@
\begin{landscape}
\begin{small}
<<echo=FALSE,results=tex>>=
#print(tab1,size="\\small",caption='Model results ranked by AIC',label='tab:mod')
print(tab1,tabular.environment="longtable", caption.placement="top",
        size="\\small", table.placement="", floating=FALSE)
@
\end{small}
\end{landscape}
\clearpage
\begin{figure}
\begin{center}
<<figmod1,fig=TRUE,echo=FALSE>>=
par(mfrow=c(2,2),mar=c(3,2,2,1))
plotfit.x(fit=modLR[[1]],x=sub$X/scaleFactor)
mtext(names(modLR)[1],cex=0.7)
plotfit.yx(x=sub$X/scaleFactor,y=sub$Y/scaleFactor,
             est=modLR[[1]],main=names(modLR)[1])
legend('topright',legend='A',box.col='white',cex=2)

plotfit.x(fit=modLR[[2]],x=sub$X/scaleFactor)
mtext(names(modLR)[2],cex=0.7)
plotfit.yx(x=sub$X/scaleFactor,y=sub$Y/scaleFactor,
             est=modLR[[2]],main=names(modLR)[2])
legend('topright',legend='B',box.col='white',cex=2)
@
\end{center}
\caption{Model results for the h1 hazard rate function with a normal perpendicular density distribution (row A) and 
half-normal (row B). LH column is perpendicular distance, x-dimension, and RH column is forward distance, y-dimension. }
\label{fig:mod1and2}
\end{figure}
\clearpage

\begin{figure}
\begin{center}
<<figmod2,fig=TRUE,echo=FALSE>>=
par(mfrow=c(2,2),mar=c(3,2,2,1))
plotfit.x(fit=modLR[[3]],x=sub$X/scaleFactor)
mtext(names(modLR)[3],cex=0.7)
plotfit.yx(x=sub$X/scaleFactor,y=sub$Y/scaleFactor,
             est=modLR[[3]],main=names(modLR)[3])
legend('topright',legend='C',box.col='white',cex=2)

plotfit.x(fit=modLR[[4]],x=sub$X/scaleFactor)
mtext(names(modLR)[4],cex=0.7)
plotfit.yx(x=sub$X/scaleFactor,y=sub$Y/scaleFactor,
             est=modLR[[4]],main=names(modLR)[4])
legend('topright',legend='D',box.col='white',cex=2)
@
\end{center}
\caption{Model results for the h1 hazard rate function with a uniform perpendicular density distribution (row C) and 
h2 hazard rate function with a normal perpendicular density distribution(row D).LH column is perpendicular distance, x-dimension, and RH column is forward distance, y-dimension.}
\label{fig:mod3and4}
\end{figure}
\clearpage


\begin{figure}
\begin{center}
<<figmod3,fig=TRUE,echo=FALSE>>=
par(mfrow=c(2,2),mar=c(3,2,2,1))
plotfit.x(fit=modLR[[5]],x=sub$X/scaleFactor)
mtext(names(modLR)[5],cex=0.7)
plotfit.yx(x=sub$X/scaleFactor,y=sub$Y/scaleFactor,
             est=modLR[[5]],main=names(modLR)[5])
legend('topright',legend='E',box.col='white',cex=2)

plotfit.x(fit=modLR[[6]],x=sub$X/scaleFactor)
mtext(names(modLR)[6],cex=0.7)
plotfit.yx(x=sub$X/scaleFactor,y=sub$Y/scaleFactor,
             est=modLR[[6]],main=names(modLR)[6])
legend('topright',legend='F',box.col='white',cex=2)
@
\end{center}
\caption{Model results for the h2 hazard rate function with a uniform perpendicular density distribution (row E) and a half-normal perpendicular density distribution (row F). LH column is perpendicular distance, x-dimension, and RH column is forward distance, y-dimension.}
\label{fig:mod5and6}
\end{figure}
\clearpage

\end{document}

